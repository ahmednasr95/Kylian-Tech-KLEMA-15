
Kylian Tech.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000ae  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  000008fc  2**0
                  ALLOC, LOAD, DATA
  2 .bss          00000002  00800060  00800060  000008fc  2**0
                  ALLOC
  3 .comment      0000002f  00000000  00000000  000008fc  2**0
                  CONTENTS, READONLY
  4 .stack.descriptors.hdr 0000000e  00000000  00000000  0000092b  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000208  00000000  00000000  00000939  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003b62  00000000  00000000  00000b41  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c5b  00000000  00000000  000046a3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000127d  00000000  00000000  000052fe  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000470  00000000  00000000  0000657c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000036a  00000000  00000000  000069ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000015bb  00000000  00000000  00006d56  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000178  00000000  00000000  00008311  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .text         00000004  0000083a  0000083a  000008ee  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000848c  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .text.app_init 00000010  000007ca  000007ca  0000087e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .progmemx.data 00000025  000000ae  000000ae  00000162  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, PROGMEMX
 17 .text.Off_Task 0000003a  00000608  00000608  000006bc  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .text.Ready_Task 00000038  00000642  00000642  000006f6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .text.Ignition_Task 0000003c  000005cc  000005cc  00000680  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .text.Check_State 00000058  00000574  00000574  00000628  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 21 .text.Run     00000030  000006b2  000006b2  00000766  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .text.app_main 00000008  00000832  00000832  000008e6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .text.__vector_11 0000007a  000004fa  000004fa  000005ae  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .bss.Interrupt_Flag 00000001  00800064  00800064  000008fc  2**0
                  ALLOC
 25 .bss.OVF_Counter 00000002  00800062  00800062  000008fc  2**0
                  ALLOC
 26 .text.BLUE_LED_Initializ 0000000e  000007ea  000007ea  0000089e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 27 .text.BLUE_LED_ON 0000000e  000007f8  000007f8  000008ac  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 28 .text.BLUE_LED_OFF 0000000e  00000806  00000806  000008ba  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 29 .text.LCD_Write_Command 000000d4  000002d0  000002d0  00000384  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 30 .text.LCD_Initialize 00000082  00000478  00000478  0000052c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .text.LCD_Clear 0000000a  00000814  00000814  000008c8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .text.LCD_Write_Character 000000d4  000003a4  000003a4  00000458  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .text.LCD_Write_String 0000002e  000006e2  000006e2  00000796  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 34 .text.LCD_LINE_position 00000028  0000073c  0000073c  000007f0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 35 .text.VR1_init 00000010  000007da  000007da  0000088e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 36 .text.VR1_Read 00000014  000007a2  000007a2  00000856  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 37 .text.main    0000000a  0000081e  0000081e  000008d2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 38 .text.ADC_Initializ 00000028  00000764  00000764  00000818  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 39 .text.ADC_Read 00000038  0000067a  0000067a  0000072e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 40 .text.DIO_SetPin_Direction 000000fe  000000d4  000000d4  00000188  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 41 .text.DIO_SetPin_Value 000000fe  000001d2  000001d2  00000286  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 42 .text.Set_Global_INT 0000002c  00000710  00000710  000007c4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 43 .text.timer0_init 00000014  000007b6  000007b6  0000086a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 44 .text.timer0_deinit 0000000a  00000828  00000828  000008dc  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 45 .text.__dummy_fini 00000002  00000842  00000842  000008f6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 46 .text.__dummy_funcs_on_exit 00000002  00000844  00000844  000008f8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 47 .text.__dummy_simulator_exit 00000002  00000846  00000846  000008fa  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 48 .text.exit    00000016  0000078c  0000078c  00000840  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 49 .text._Exit   00000004  0000083e  0000083e  000008f2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2d 00 	jmp	0x5a	; 0x5a <__ctors_end>
   4:	0c 94 1d 04 	jmp	0x83a	; 0x83a <__bad_interrupt>
   8:	0c 94 1d 04 	jmp	0x83a	; 0x83a <__bad_interrupt>
   c:	0c 94 1d 04 	jmp	0x83a	; 0x83a <__bad_interrupt>
  10:	0c 94 1d 04 	jmp	0x83a	; 0x83a <__bad_interrupt>
  14:	0c 94 1d 04 	jmp	0x83a	; 0x83a <__bad_interrupt>
  18:	0c 94 1d 04 	jmp	0x83a	; 0x83a <__bad_interrupt>
  1c:	0c 94 1d 04 	jmp	0x83a	; 0x83a <__bad_interrupt>
  20:	0c 94 1d 04 	jmp	0x83a	; 0x83a <__bad_interrupt>
  24:	0c 94 1d 04 	jmp	0x83a	; 0x83a <__bad_interrupt>
  28:	0c 94 1d 04 	jmp	0x83a	; 0x83a <__bad_interrupt>
  2c:	0c 94 7d 02 	jmp	0x4fa	; 0x4fa <__vector_11>
  30:	0c 94 1d 04 	jmp	0x83a	; 0x83a <__bad_interrupt>
  34:	0c 94 1d 04 	jmp	0x83a	; 0x83a <__bad_interrupt>
  38:	0c 94 1d 04 	jmp	0x83a	; 0x83a <__bad_interrupt>
  3c:	0c 94 1d 04 	jmp	0x83a	; 0x83a <__bad_interrupt>
  40:	0c 94 1d 04 	jmp	0x83a	; 0x83a <__bad_interrupt>
  44:	0c 94 1d 04 	jmp	0x83a	; 0x83a <__bad_interrupt>
  48:	0c 94 1d 04 	jmp	0x83a	; 0x83a <__bad_interrupt>
  4c:	0c 94 1d 04 	jmp	0x83a	; 0x83a <__bad_interrupt>
  50:	0c 94 1d 04 	jmp	0x83a	; 0x83a <__bad_interrupt>

00000054 <.dinit>:
  54:	00 60       	ori	r16, 0x00	; 0
  56:	00 65       	ori	r16, 0x50	; 80
  58:	80 00       	.word	0x0080	; ????

0000005a <__ctors_end>:
  5a:	11 24       	eor	r1, r1
  5c:	1f be       	out	0x3f, r1	; 63
  5e:	cf e5       	ldi	r28, 0x5F	; 95
  60:	d8 e0       	ldi	r29, 0x08	; 8
  62:	de bf       	out	0x3e, r29	; 62
  64:	cd bf       	out	0x3d, r28	; 61

00000066 <__do_copy_data>:
  66:	e4 e5       	ldi	r30, 0x54	; 84
  68:	f0 e0       	ldi	r31, 0x00	; 0
  6a:	40 e0       	ldi	r20, 0x00	; 0
  6c:	17 c0       	rjmp	.+46     	; 0x9c <__do_clear_bss+0x8>
  6e:	b5 91       	lpm	r27, Z+
  70:	a5 91       	lpm	r26, Z+
  72:	35 91       	lpm	r19, Z+
  74:	25 91       	lpm	r18, Z+
  76:	05 91       	lpm	r16, Z+
  78:	07 fd       	sbrc	r16, 7
  7a:	0c c0       	rjmp	.+24     	; 0x94 <__do_clear_bss>
  7c:	95 91       	lpm	r25, Z+
  7e:	85 91       	lpm	r24, Z+
  80:	ef 01       	movw	r28, r30
  82:	f9 2f       	mov	r31, r25
  84:	e8 2f       	mov	r30, r24
  86:	05 90       	lpm	r0, Z+
  88:	0d 92       	st	X+, r0
  8a:	a2 17       	cp	r26, r18
  8c:	b3 07       	cpc	r27, r19
  8e:	d9 f7       	brne	.-10     	; 0x86 <__do_copy_data+0x20>
  90:	fe 01       	movw	r30, r28
  92:	04 c0       	rjmp	.+8      	; 0x9c <__do_clear_bss+0x8>

00000094 <__do_clear_bss>:
  94:	1d 92       	st	X+, r1
  96:	a2 17       	cp	r26, r18
  98:	b3 07       	cpc	r27, r19
  9a:	e1 f7       	brne	.-8      	; 0x94 <__do_clear_bss>
  9c:	e9 35       	cpi	r30, 0x59	; 89
  9e:	f4 07       	cpc	r31, r20
  a0:	31 f7       	brne	.-52     	; 0x6e <__do_copy_data+0x8>
  a2:	0e 94 0f 04 	call	0x81e	; 0x81e <main>
  a6:	0c 94 c6 03 	jmp	0x78c	; 0x78c <exit>

000000aa <_exit>:
  aa:	f8 94       	cli

000000ac <__stop_program>:
  ac:	ff cf       	rjmp	.-2      	; 0xac <__stop_program>

Disassembly of section .text:

0000083a <__bad_interrupt>:
 83a:	0c 94 00 00 	jmp	0	; 0x0 <__TEXT_REGION_ORIGIN__>

Disassembly of section .text.app_init:

000007ca <app_init>:
 * return: Error State
 */
 
ERROR_STATE app_init(){
		ERROR_STATE state_error = SUCCESS;
		LCD_Initialize();
 7ca:	0e 94 3c 02 	call	0x478	; 0x478 <LCD_Initialize>
		BLUE_LED_Initializ();
 7ce:	0e 94 f5 03 	call	0x7ea	; 0x7ea <BLUE_LED_Initializ>
		VR1_init();
 7d2:	0e 94 ed 03 	call	0x7da	; 0x7da <VR1_init>
		return state_error;
}
 7d6:	81 e0       	ldi	r24, 0x01	; 1
 7d8:	08 95       	ret

Disassembly of section .text.Off_Task:

00000608 <Off_Task>:
 * input: void
 * return: Error State
 */
 ERROR_STATE Off_Task(void){
	 ERROR_STATE state_error = SUCCESS;
	 Interrupt_Flag=false;
 608:	10 92 64 00 	sts	0x0064, r1	; 0x800064 <Interrupt_Flag>
	 if (Previous_State==READY_state){
 60c:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 610:	81 30       	cpi	r24, 0x01	; 1
 612:	11 f4       	brne	.+4      	; 0x618 <Off_Task+0x10>
		 LCD_Clear();
 614:	0e 94 0a 04 	call	0x814	; 0x814 <LCD_Clear>
	 } 
	 else {
		 /* Do Nothing*/
	 }
	 LCD_LINE_position(0,0);
 618:	60 e0       	ldi	r22, 0x00	; 0
 61a:	80 e0       	ldi	r24, 0x00	; 0
 61c:	0e 94 9e 03 	call	0x73c	; 0x73c <LCD_LINE_position>
	 LCD_Write_String("OFF STATE");
 620:	6e ea       	ldi	r22, 0xAE	; 174
 622:	70 e0       	ldi	r23, 0x00	; 0
 624:	80 e0       	ldi	r24, 0x00	; 0
 626:	0e 94 71 03 	call	0x6e2	; 0x6e2 <LCD_Write_String>
	 timer0_deinit();
 62a:	0e 94 14 04 	call	0x828	; 0x828 <timer0_deinit>
	  OVF_Counter=0;
 62e:	10 92 63 00 	sts	0x0063, r1	; 0x800063 <OVF_Counter+0x1>
 632:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <OVF_Counter>
	 BLUE_LED_OFF();
 636:	0e 94 03 04 	call	0x806	; 0x806 <BLUE_LED_OFF>
	 Previous_State=OFF;
 63a:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>

	 return state_error;
 }
 63e:	81 e0       	ldi	r24, 0x01	; 1
 640:	08 95       	ret

Disassembly of section .text.Ready_Task:

00000642 <Ready_Task>:
 * input: void
 * return: Error State
 */
 ERROR_STATE Ready_Task(void){
	 ERROR_STATE state_error = SUCCESS;
	 if (Previous_State!=READY_state){
 642:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 646:	81 30       	cpi	r24, 0x01	; 1
 648:	39 f0       	breq	.+14     	; 0x658 <Ready_Task+0x16>
		LCD_Clear();
 64a:	0e 94 0a 04 	call	0x814	; 0x814 <LCD_Clear>
		 timer0_init();
 64e:	0e 94 db 03 	call	0x7b6	; 0x7b6 <timer0_init>
		 
		 Previous_State=READY_state;
 652:	81 e0       	ldi	r24, 0x01	; 1
 654:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
	 }
	 else {
		 /* Do Nothing*/
	 }

		 LCD_LINE_position(0,0);
 658:	60 e0       	ldi	r22, 0x00	; 0
 65a:	80 e0       	ldi	r24, 0x00	; 0
 65c:	0e 94 9e 03 	call	0x73c	; 0x73c <LCD_LINE_position>
		 LCD_Write_String("READY STATE");
 660:	68 eb       	ldi	r22, 0xB8	; 184
 662:	70 e0       	ldi	r23, 0x00	; 0
 664:	80 e0       	ldi	r24, 0x00	; 0
 666:	0e 94 71 03 	call	0x6e2	; 0x6e2 <LCD_Write_String>
		 if (Interrupt_Flag==0)
 66a:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <Interrupt_Flag>
 66e:	81 11       	cpse	r24, r1
 670:	02 c0       	rjmp	.+4      	; 0x676 <Ready_Task+0x34>
		 BLUE_LED_ON();
 672:	0e 94 fc 03 	call	0x7f8	; 0x7f8 <BLUE_LED_ON>
	
	 return state_error;
 }
 676:	81 e0       	ldi	r24, 0x01	; 1
 678:	08 95       	ret

Disassembly of section .text.Ignition_Task:

000005cc <Ignition_Task>:
 * input: void
 * return: Error State
 */
  ERROR_STATE Ignition_Task(void){
	  ERROR_STATE state_error = SUCCESS;
	  Interrupt_Flag=0;
 5cc:	10 92 64 00 	sts	0x0064, r1	; 0x800064 <Interrupt_Flag>
	  if (Previous_State!=IGNITION){
 5d0:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 5d4:	82 30       	cpi	r24, 0x02	; 2
 5d6:	11 f0       	breq	.+4      	; 0x5dc <Ignition_Task+0x10>
		  LCD_Clear();
 5d8:	0e 94 0a 04 	call	0x814	; 0x814 <LCD_Clear>
	  }
	  else {
		  /* Do Nothing*/
	  }
	   LCD_LINE_position(0,0);
 5dc:	60 e0       	ldi	r22, 0x00	; 0
 5de:	80 e0       	ldi	r24, 0x00	; 0
 5e0:	0e 94 9e 03 	call	0x73c	; 0x73c <LCD_LINE_position>
	  LCD_Write_String("IGNITION STATE");
 5e4:	64 ec       	ldi	r22, 0xC4	; 196
 5e6:	70 e0       	ldi	r23, 0x00	; 0
 5e8:	80 e0       	ldi	r24, 0x00	; 0
 5ea:	0e 94 71 03 	call	0x6e2	; 0x6e2 <LCD_Write_String>
	  timer0_deinit();
 5ee:	0e 94 14 04 	call	0x828	; 0x828 <timer0_deinit>
	  OVF_Counter=0;
 5f2:	10 92 63 00 	sts	0x0063, r1	; 0x800063 <OVF_Counter+0x1>
 5f6:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <OVF_Counter>
	  BLUE_LED_ON();
 5fa:	0e 94 fc 03 	call	0x7f8	; 0x7f8 <BLUE_LED_ON>
	  Previous_State=IGNITION;
 5fe:	82 e0       	ldi	r24, 0x02	; 2
 600:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
	  return state_error;
  }
 604:	81 e0       	ldi	r24, 0x01	; 1
 606:	08 95       	ret

Disassembly of section .text.Check_State:

00000574 <Check_State>:
 /*
 * Description:Algorithm to check the Potentiometer Reading
 * input: void
 * return: Error State
 */
ERROR_STATE Check_State(){
 574:	cf 93       	push	r28
 576:	df 93       	push	r29
 578:	00 d0       	rcall	.+0      	; 0x57a <Check_State+0x6>
 57a:	cd b7       	in	r28, 0x3d	; 61
 57c:	de b7       	in	r29, 0x3e	; 62
	
	ERROR_STATE state_error = SUCCESS;
	UINT16_t reading;
	state_error=VR1_Read(&reading);
 57e:	ce 01       	movw	r24, r28
 580:	01 96       	adiw	r24, 0x01	; 1
 582:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <VR1_Read>
	if (state_error == SUCCESS)
 586:	81 30       	cpi	r24, 0x01	; 1
 588:	c9 f4       	brne	.+50     	; 0x5bc <Check_State+0x48>
	{
		if (reading>=RANGE_BOUNADRY_1 && reading<RANGE_BOUNADRY_2)
 58a:	29 81       	ldd	r18, Y+1	; 0x01
 58c:	3a 81       	ldd	r19, Y+2	; 0x02
 58e:	22 33       	cpi	r18, 0x32	; 50
 590:	31 05       	cpc	r19, r1
 592:	18 f4       	brcc	.+6      	; 0x59a <Check_State+0x26>
		{
			Current_State=OFF_State;
 594:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <Current_State>
 598:	14 c0       	rjmp	.+40     	; 0x5c2 <Check_State+0x4e>
		} 
		else if (reading>=RANGE_BOUNADRY_2 && reading <RANGE_BOUNDARY_3)
 59a:	a9 01       	movw	r20, r18
 59c:	42 53       	subi	r20, 0x32	; 50
 59e:	51 09       	sbc	r21, r1
 5a0:	42 33       	cpi	r20, 0x32	; 50
 5a2:	51 05       	cpc	r21, r1
 5a4:	20 f4       	brcc	.+8      	; 0x5ae <Check_State+0x3a>
		{
			Current_State=READY_state;
 5a6:	91 e0       	ldi	r25, 0x01	; 1
 5a8:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <Current_State>
 5ac:	0a c0       	rjmp	.+20     	; 0x5c2 <Check_State+0x4e>
		}
		else if (reading>RANGE_BOUNDARY_3)
 5ae:	25 36       	cpi	r18, 0x65	; 101
 5b0:	31 05       	cpc	r19, r1
 5b2:	30 f0       	brcs	.+12     	; 0x5c0 <Check_State+0x4c>
		{
			Current_State=IGNITION;
 5b4:	92 e0       	ldi	r25, 0x02	; 2
 5b6:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <Current_State>
 5ba:	03 c0       	rjmp	.+6      	; 0x5c2 <Check_State+0x4e>
		}
			
	}
	else 
	{
		state_error=FAIL;
 5bc:	80 e0       	ldi	r24, 0x00	; 0
 5be:	01 c0       	rjmp	.+2      	; 0x5c2 <Check_State+0x4e>
		{
			Current_State=IGNITION;
		} 
		else
	    {
			state_error=FAIL;
 5c0:	80 e0       	ldi	r24, 0x00	; 0
	{
		state_error=FAIL;
	} 
	
	return state_error;
}
 5c2:	0f 90       	pop	r0
 5c4:	0f 90       	pop	r0
 5c6:	df 91       	pop	r29
 5c8:	cf 91       	pop	r28
 5ca:	08 95       	ret

Disassembly of section .text.Run:

000006b2 <Run>:
 * input: void
 * return: Error State
 */
ERROR_STATE Run(){
	ERROR_STATE state_error = SUCCESS;
	Check_State();
 6b2:	0e 94 ba 02 	call	0x574	; 0x574 <Check_State>
	if(Current_State==OFF_State)
 6b6:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <Current_State>
 6ba:	81 11       	cpse	r24, r1
 6bc:	04 c0       	rjmp	.+8      	; 0x6c6 <Run+0x14>
	{
		Off_Task();
 6be:	0e 94 04 03 	call	0x608	; 0x608 <Off_Task>
 * Description: the Algorithm of the system
 * input: void
 * return: Error State
 */
ERROR_STATE Run(){
	ERROR_STATE state_error = SUCCESS;
 6c2:	81 e0       	ldi	r24, 0x01	; 1
 6c4:	08 95       	ret
	Check_State();
	if(Current_State==OFF_State)
	{
		Off_Task();
	}
	else if( Current_State==READY_state)
 6c6:	81 30       	cpi	r24, 0x01	; 1
 6c8:	21 f4       	brne	.+8      	; 0x6d2 <Run+0x20>
	{
		Ready_Task();
 6ca:	0e 94 21 03 	call	0x642	; 0x642 <Ready_Task>
 * Description: the Algorithm of the system
 * input: void
 * return: Error State
 */
ERROR_STATE Run(){
	ERROR_STATE state_error = SUCCESS;
 6ce:	81 e0       	ldi	r24, 0x01	; 1
 6d0:	08 95       	ret
	}
	else if( Current_State==READY_state)
	{
		Ready_Task();
	}
	else if(Current_State==IGNITION)
 6d2:	82 30       	cpi	r24, 0x02	; 2
 6d4:	21 f4       	brne	.+8      	; 0x6de <Run+0x2c>
	{
		Ignition_Task();
 6d6:	0e 94 e6 02 	call	0x5cc	; 0x5cc <Ignition_Task>
 * Description: the Algorithm of the system
 * input: void
 * return: Error State
 */
ERROR_STATE Run(){
	ERROR_STATE state_error = SUCCESS;
 6da:	81 e0       	ldi	r24, 0x01	; 1
 6dc:	08 95       	ret
	{
		Ignition_Task();
	}
	else
	{
		state_error=FAIL;
 6de:	80 e0       	ldi	r24, 0x00	; 0
	}
	return state_error;
}
 6e0:	08 95       	ret

Disassembly of section .text.app_main:

00000832 <app_main>:
 * input: void
 * return: Error State
 */
ERROR_STATE app_main(){
		ERROR_STATE state_error = SUCCESS;
		Run();
 832:	0e 94 59 03 	call	0x6b2	; 0x6b2 <Run>
		return state_error;
}
 836:	81 e0       	ldi	r24, 0x01	; 1
 838:	08 95       	ret

Disassembly of section .text.__vector_11:

000004fa <__vector_11>:
	} 
	
	return state_error;
}

ISR(VECTOR(11)){
 4fa:	1f 92       	push	r1
 4fc:	0f 92       	push	r0
 4fe:	0f b6       	in	r0, 0x3f	; 63
 500:	0f 92       	push	r0
 502:	11 24       	eor	r1, r1
 504:	2f 93       	push	r18
 506:	3f 93       	push	r19
 508:	4f 93       	push	r20
 50a:	5f 93       	push	r21
 50c:	6f 93       	push	r22
 50e:	7f 93       	push	r23
 510:	8f 93       	push	r24
 512:	9f 93       	push	r25
 514:	af 93       	push	r26
 516:	bf 93       	push	r27
 518:	ef 93       	push	r30
 51a:	ff 93       	push	r31

	if (OVF_Counter==NB_OF_OVERFLOWS_IN_TIMOUT){
 51c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <OVF_Counter>
 520:	90 91 63 00 	lds	r25, 0x0063	; 0x800063 <OVF_Counter+0x1>
 524:	85 3c       	cpi	r24, 0xC5	; 197
 526:	94 40       	sbci	r25, 0x04	; 4
 528:	59 f4       	brne	.+22     	; 0x540 <__vector_11+0x46>
		Current_State=OFF_State;
 52a:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <Current_State>
		BLUE_LED_OFF();
 52e:	0e 94 03 04 	call	0x806	; 0x806 <BLUE_LED_OFF>
		OVF_Counter=0;
 532:	10 92 63 00 	sts	0x0063, r1	; 0x800063 <OVF_Counter+0x1>
 536:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <OVF_Counter>
		Interrupt_Flag=true;
 53a:	81 e0       	ldi	r24, 0x01	; 1
 53c:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <Interrupt_Flag>
		
	}
		OVF_Counter++;
 540:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <OVF_Counter>
 544:	90 91 63 00 	lds	r25, 0x0063	; 0x800063 <OVF_Counter+0x1>
 548:	01 96       	adiw	r24, 0x01	; 1
 54a:	90 93 63 00 	sts	0x0063, r25	; 0x800063 <OVF_Counter+0x1>
 54e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <OVF_Counter>

}
 552:	ff 91       	pop	r31
 554:	ef 91       	pop	r30
 556:	bf 91       	pop	r27
 558:	af 91       	pop	r26
 55a:	9f 91       	pop	r25
 55c:	8f 91       	pop	r24
 55e:	7f 91       	pop	r23
 560:	6f 91       	pop	r22
 562:	5f 91       	pop	r21
 564:	4f 91       	pop	r20
 566:	3f 91       	pop	r19
 568:	2f 91       	pop	r18
 56a:	0f 90       	pop	r0
 56c:	0f be       	out	0x3f, r0	; 63
 56e:	0f 90       	pop	r0
 570:	1f 90       	pop	r1
 572:	18 95       	reti

Disassembly of section .text.BLUE_LED_Initializ:

000007ea <BLUE_LED_Initializ>:
 7ea:	41 e0       	ldi	r20, 0x01	; 1
 7ec:	65 e0       	ldi	r22, 0x05	; 5
 7ee:	80 e0       	ldi	r24, 0x00	; 0
 7f0:	0e 94 6a 00 	call	0xd4	; 0xd4 <DIO_SetPin_Direction>
 7f4:	81 e0       	ldi	r24, 0x01	; 1
 7f6:	08 95       	ret

Disassembly of section .text.BLUE_LED_ON:

000007f8 <BLUE_LED_ON>:
 7f8:	41 e0       	ldi	r20, 0x01	; 1
 7fa:	65 e0       	ldi	r22, 0x05	; 5
 7fc:	80 e0       	ldi	r24, 0x00	; 0
 7fe:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 802:	81 e0       	ldi	r24, 0x01	; 1
 804:	08 95       	ret

Disassembly of section .text.BLUE_LED_OFF:

00000806 <BLUE_LED_OFF>:
 806:	40 e0       	ldi	r20, 0x00	; 0
 808:	65 e0       	ldi	r22, 0x05	; 5
 80a:	80 e0       	ldi	r24, 0x00	; 0
 80c:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 810:	81 e0       	ldi	r24, 0x01	; 1
 812:	08 95       	ret

Disassembly of section .text.LCD_Write_Command:

000002d0 <LCD_Write_Command>:
ERROR_STATE LCD_Write_SpecialCharacter(UINT8_t Scharcter)
{
	ERROR_STATE state_error = SUCCESS;
	LCD_Write_Character(Scharcter);
	return state_error;
}
 2d0:	cf 93       	push	r28
 2d2:	c8 2f       	mov	r28, r24
 2d4:	48 2f       	mov	r20, r24
 2d6:	44 1f       	adc	r20, r20
 2d8:	44 27       	eor	r20, r20
 2da:	44 1f       	adc	r20, r20
 2dc:	64 e0       	ldi	r22, 0x04	; 4
 2de:	81 e0       	ldi	r24, 0x01	; 1
 2e0:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 2e4:	c6 fb       	bst	r28, 6
 2e6:	44 27       	eor	r20, r20
 2e8:	40 f9       	bld	r20, 0
 2ea:	62 e0       	ldi	r22, 0x02	; 2
 2ec:	81 e0       	ldi	r24, 0x01	; 1
 2ee:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 2f2:	c5 fb       	bst	r28, 5
 2f4:	44 27       	eor	r20, r20
 2f6:	40 f9       	bld	r20, 0
 2f8:	61 e0       	ldi	r22, 0x01	; 1
 2fa:	81 e0       	ldi	r24, 0x01	; 1
 2fc:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 300:	c4 fb       	bst	r28, 4
 302:	44 27       	eor	r20, r20
 304:	40 f9       	bld	r20, 0
 306:	60 e0       	ldi	r22, 0x00	; 0
 308:	81 e0       	ldi	r24, 0x01	; 1
 30a:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 30e:	40 e0       	ldi	r20, 0x00	; 0
 310:	63 e0       	ldi	r22, 0x03	; 3
 312:	80 e0       	ldi	r24, 0x00	; 0
 314:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 318:	41 e0       	ldi	r20, 0x01	; 1
 31a:	62 e0       	ldi	r22, 0x02	; 2
 31c:	80 e0       	ldi	r24, 0x00	; 0
 31e:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 322:	85 e0       	ldi	r24, 0x05	; 5
 324:	8a 95       	dec	r24
 326:	f1 f7       	brne	.-4      	; 0x324 <LCD_Write_Command+0x54>
 328:	00 00       	nop
 32a:	40 e0       	ldi	r20, 0x00	; 0
 32c:	62 e0       	ldi	r22, 0x02	; 2
 32e:	80 e0       	ldi	r24, 0x00	; 0
 330:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 334:	8f e1       	ldi	r24, 0x1F	; 31
 336:	93 e0       	ldi	r25, 0x03	; 3
 338:	01 97       	sbiw	r24, 0x01	; 1
 33a:	f1 f7       	brne	.-4      	; 0x338 <LCD_Write_Command+0x68>
 33c:	00 c0       	rjmp	.+0      	; 0x33e <LCD_Write_Command+0x6e>
 33e:	00 00       	nop
 340:	c3 fb       	bst	r28, 3
 342:	44 27       	eor	r20, r20
 344:	40 f9       	bld	r20, 0
 346:	64 e0       	ldi	r22, 0x04	; 4
 348:	81 e0       	ldi	r24, 0x01	; 1
 34a:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 34e:	c2 fb       	bst	r28, 2
 350:	44 27       	eor	r20, r20
 352:	40 f9       	bld	r20, 0
 354:	62 e0       	ldi	r22, 0x02	; 2
 356:	81 e0       	ldi	r24, 0x01	; 1
 358:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 35c:	c1 fb       	bst	r28, 1
 35e:	44 27       	eor	r20, r20
 360:	40 f9       	bld	r20, 0
 362:	61 e0       	ldi	r22, 0x01	; 1
 364:	81 e0       	ldi	r24, 0x01	; 1
 366:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 36a:	4c 2f       	mov	r20, r28
 36c:	41 70       	andi	r20, 0x01	; 1
 36e:	60 e0       	ldi	r22, 0x00	; 0
 370:	81 e0       	ldi	r24, 0x01	; 1
 372:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 376:	41 e0       	ldi	r20, 0x01	; 1
 378:	62 e0       	ldi	r22, 0x02	; 2
 37a:	80 e0       	ldi	r24, 0x00	; 0
 37c:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 380:	95 e0       	ldi	r25, 0x05	; 5
 382:	9a 95       	dec	r25
 384:	f1 f7       	brne	.-4      	; 0x382 <LCD_Write_Command+0xb2>
 386:	00 00       	nop
 388:	40 e0       	ldi	r20, 0x00	; 0
 38a:	62 e0       	ldi	r22, 0x02	; 2
 38c:	80 e0       	ldi	r24, 0x00	; 0
 38e:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 392:	8f e3       	ldi	r24, 0x3F	; 63
 394:	9f e1       	ldi	r25, 0x1F	; 31
 396:	01 97       	sbiw	r24, 0x01	; 1
 398:	f1 f7       	brne	.-4      	; 0x396 <LCD_Write_Command+0xc6>
 39a:	00 c0       	rjmp	.+0      	; 0x39c <LCD_Write_Command+0xcc>
 39c:	00 00       	nop
 39e:	81 e0       	ldi	r24, 0x01	; 1
 3a0:	cf 91       	pop	r28
 3a2:	08 95       	ret

Disassembly of section .text.LCD_Initialize:

00000478 <LCD_Initialize>:
 478:	41 e0       	ldi	r20, 0x01	; 1
 47a:	60 e0       	ldi	r22, 0x00	; 0
 47c:	81 e0       	ldi	r24, 0x01	; 1
 47e:	0e 94 6a 00 	call	0xd4	; 0xd4 <DIO_SetPin_Direction>
 482:	41 e0       	ldi	r20, 0x01	; 1
 484:	61 e0       	ldi	r22, 0x01	; 1
 486:	81 e0       	ldi	r24, 0x01	; 1
 488:	0e 94 6a 00 	call	0xd4	; 0xd4 <DIO_SetPin_Direction>
 48c:	41 e0       	ldi	r20, 0x01	; 1
 48e:	62 e0       	ldi	r22, 0x02	; 2
 490:	81 e0       	ldi	r24, 0x01	; 1
 492:	0e 94 6a 00 	call	0xd4	; 0xd4 <DIO_SetPin_Direction>
 496:	41 e0       	ldi	r20, 0x01	; 1
 498:	64 e0       	ldi	r22, 0x04	; 4
 49a:	81 e0       	ldi	r24, 0x01	; 1
 49c:	0e 94 6a 00 	call	0xd4	; 0xd4 <DIO_SetPin_Direction>
 4a0:	41 e0       	ldi	r20, 0x01	; 1
 4a2:	63 e0       	ldi	r22, 0x03	; 3
 4a4:	80 e0       	ldi	r24, 0x00	; 0
 4a6:	0e 94 6a 00 	call	0xd4	; 0xd4 <DIO_SetPin_Direction>
 4aa:	41 e0       	ldi	r20, 0x01	; 1
 4ac:	62 e0       	ldi	r22, 0x02	; 2
 4ae:	80 e0       	ldi	r24, 0x00	; 0
 4b0:	0e 94 6a 00 	call	0xd4	; 0xd4 <DIO_SetPin_Direction>
 4b4:	2f ef       	ldi	r18, 0xFF	; 255
 4b6:	89 ef       	ldi	r24, 0xF9	; 249
 4b8:	90 e0       	ldi	r25, 0x00	; 0
 4ba:	21 50       	subi	r18, 0x01	; 1
 4bc:	80 40       	sbci	r24, 0x00	; 0
 4be:	90 40       	sbci	r25, 0x00	; 0
 4c0:	e1 f7       	brne	.-8      	; 0x4ba <LCD_Initialize+0x42>
 4c2:	00 c0       	rjmp	.+0      	; 0x4c4 <LCD_Initialize+0x4c>
 4c4:	00 00       	nop
 4c6:	82 e0       	ldi	r24, 0x02	; 2
 4c8:	0e 94 68 01 	call	0x2d0	; 0x2d0 <LCD_Write_Command>
 4cc:	88 e2       	ldi	r24, 0x28	; 40
 4ce:	0e 94 68 01 	call	0x2d0	; 0x2d0 <LCD_Write_Command>
 4d2:	8c e0       	ldi	r24, 0x0C	; 12
 4d4:	0e 94 68 01 	call	0x2d0	; 0x2d0 <LCD_Write_Command>
 4d8:	86 e0       	ldi	r24, 0x06	; 6
 4da:	0e 94 68 01 	call	0x2d0	; 0x2d0 <LCD_Write_Command>
 4de:	81 e0       	ldi	r24, 0x01	; 1
 4e0:	0e 94 68 01 	call	0x2d0	; 0x2d0 <LCD_Write_Command>
 4e4:	2f ef       	ldi	r18, 0xFF	; 255
 4e6:	89 ef       	ldi	r24, 0xF9	; 249
 4e8:	90 e0       	ldi	r25, 0x00	; 0
 4ea:	21 50       	subi	r18, 0x01	; 1
 4ec:	80 40       	sbci	r24, 0x00	; 0
 4ee:	90 40       	sbci	r25, 0x00	; 0
 4f0:	e1 f7       	brne	.-8      	; 0x4ea <LCD_Initialize+0x72>
 4f2:	00 c0       	rjmp	.+0      	; 0x4f4 <LCD_Initialize+0x7c>
 4f4:	00 00       	nop
 4f6:	81 e0       	ldi	r24, 0x01	; 1
 4f8:	08 95       	ret

Disassembly of section .text.LCD_Clear:

00000814 <LCD_Clear>:
 * return: Error State
 */
ERROR_STATE LCD_Clear(void)
{
	ERROR_STATE state_error = SUCCESS;
	LCD_Write_Command(0x01);
 814:	81 e0       	ldi	r24, 0x01	; 1
 816:	0e 94 68 01 	call	0x2d0	; 0x2d0 <LCD_Write_Command>
	return state_error;
}
 81a:	81 e0       	ldi	r24, 0x01	; 1
 81c:	08 95       	ret

Disassembly of section .text.LCD_Write_Character:

000003a4 <LCD_Write_Character>:
ERROR_STATE LCD_Write_SpecialCharacter(UINT8_t Scharcter)
{
	ERROR_STATE state_error = SUCCESS;
	LCD_Write_Character(Scharcter);
	return state_error;
}
 3a4:	cf 93       	push	r28
 3a6:	c8 2f       	mov	r28, r24
 3a8:	48 2f       	mov	r20, r24
 3aa:	44 1f       	adc	r20, r20
 3ac:	44 27       	eor	r20, r20
 3ae:	44 1f       	adc	r20, r20
 3b0:	64 e0       	ldi	r22, 0x04	; 4
 3b2:	81 e0       	ldi	r24, 0x01	; 1
 3b4:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 3b8:	c6 fb       	bst	r28, 6
 3ba:	44 27       	eor	r20, r20
 3bc:	40 f9       	bld	r20, 0
 3be:	62 e0       	ldi	r22, 0x02	; 2
 3c0:	81 e0       	ldi	r24, 0x01	; 1
 3c2:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 3c6:	c5 fb       	bst	r28, 5
 3c8:	44 27       	eor	r20, r20
 3ca:	40 f9       	bld	r20, 0
 3cc:	61 e0       	ldi	r22, 0x01	; 1
 3ce:	81 e0       	ldi	r24, 0x01	; 1
 3d0:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 3d4:	c4 fb       	bst	r28, 4
 3d6:	44 27       	eor	r20, r20
 3d8:	40 f9       	bld	r20, 0
 3da:	60 e0       	ldi	r22, 0x00	; 0
 3dc:	81 e0       	ldi	r24, 0x01	; 1
 3de:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 3e2:	41 e0       	ldi	r20, 0x01	; 1
 3e4:	63 e0       	ldi	r22, 0x03	; 3
 3e6:	80 e0       	ldi	r24, 0x00	; 0
 3e8:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 3ec:	41 e0       	ldi	r20, 0x01	; 1
 3ee:	62 e0       	ldi	r22, 0x02	; 2
 3f0:	80 e0       	ldi	r24, 0x00	; 0
 3f2:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 3f6:	85 e0       	ldi	r24, 0x05	; 5
 3f8:	8a 95       	dec	r24
 3fa:	f1 f7       	brne	.-4      	; 0x3f8 <LCD_Write_Character+0x54>
 3fc:	00 00       	nop
 3fe:	40 e0       	ldi	r20, 0x00	; 0
 400:	62 e0       	ldi	r22, 0x02	; 2
 402:	80 e0       	ldi	r24, 0x00	; 0
 404:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 408:	8f e1       	ldi	r24, 0x1F	; 31
 40a:	93 e0       	ldi	r25, 0x03	; 3
 40c:	01 97       	sbiw	r24, 0x01	; 1
 40e:	f1 f7       	brne	.-4      	; 0x40c <__EEPROM_REGION_LENGTH__+0xc>
 410:	00 c0       	rjmp	.+0      	; 0x412 <__EEPROM_REGION_LENGTH__+0x12>
 412:	00 00       	nop
 414:	c3 fb       	bst	r28, 3
 416:	44 27       	eor	r20, r20
 418:	40 f9       	bld	r20, 0
 41a:	64 e0       	ldi	r22, 0x04	; 4
 41c:	81 e0       	ldi	r24, 0x01	; 1
 41e:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 422:	c2 fb       	bst	r28, 2
 424:	44 27       	eor	r20, r20
 426:	40 f9       	bld	r20, 0
 428:	62 e0       	ldi	r22, 0x02	; 2
 42a:	81 e0       	ldi	r24, 0x01	; 1
 42c:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 430:	c1 fb       	bst	r28, 1
 432:	44 27       	eor	r20, r20
 434:	40 f9       	bld	r20, 0
 436:	61 e0       	ldi	r22, 0x01	; 1
 438:	81 e0       	ldi	r24, 0x01	; 1
 43a:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 43e:	4c 2f       	mov	r20, r28
 440:	41 70       	andi	r20, 0x01	; 1
 442:	60 e0       	ldi	r22, 0x00	; 0
 444:	81 e0       	ldi	r24, 0x01	; 1
 446:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 44a:	41 e0       	ldi	r20, 0x01	; 1
 44c:	62 e0       	ldi	r22, 0x02	; 2
 44e:	80 e0       	ldi	r24, 0x00	; 0
 450:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 454:	95 e0       	ldi	r25, 0x05	; 5
 456:	9a 95       	dec	r25
 458:	f1 f7       	brne	.-4      	; 0x456 <__EEPROM_REGION_LENGTH__+0x56>
 45a:	00 00       	nop
 45c:	40 e0       	ldi	r20, 0x00	; 0
 45e:	62 e0       	ldi	r22, 0x02	; 2
 460:	80 e0       	ldi	r24, 0x00	; 0
 462:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <DIO_SetPin_Value>
 466:	8f e3       	ldi	r24, 0x3F	; 63
 468:	9f e1       	ldi	r25, 0x1F	; 31
 46a:	01 97       	sbiw	r24, 0x01	; 1
 46c:	f1 f7       	brne	.-4      	; 0x46a <__EEPROM_REGION_LENGTH__+0x6a>
 46e:	00 c0       	rjmp	.+0      	; 0x470 <__EEPROM_REGION_LENGTH__+0x70>
 470:	00 00       	nop
 472:	81 e0       	ldi	r24, 0x01	; 1
 474:	cf 91       	pop	r28
 476:	08 95       	ret

Disassembly of section .text.LCD_Write_String:

000006e2 <LCD_Write_String>:
 6e2:	cf 92       	push	r12
 6e4:	df 92       	push	r13
 6e6:	ef 92       	push	r14
 6e8:	6b 01       	movw	r12, r22
 6ea:	e8 2e       	mov	r14, r24
 6ec:	06 c0       	rjmp	.+12     	; 0x6fa <LCD_Write_String+0x18>
 6ee:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCD_Write_Character>
 6f2:	8f ef       	ldi	r24, 0xFF	; 255
 6f4:	c8 1a       	sub	r12, r24
 6f6:	d8 0a       	sbc	r13, r24
 6f8:	e8 0a       	sbc	r14, r24
 6fa:	f6 01       	movw	r30, r12
 6fc:	84 91       	lpm	r24, Z
 6fe:	e7 fc       	sbrc	r14, 7
 700:	80 81       	ld	r24, Z
 702:	81 11       	cpse	r24, r1
 704:	f4 cf       	rjmp	.-24     	; 0x6ee <LCD_Write_String+0xc>
 706:	81 e0       	ldi	r24, 0x01	; 1
 708:	ef 90       	pop	r14
 70a:	df 90       	pop	r13
 70c:	cf 90       	pop	r12
 70e:	08 95       	ret

Disassembly of section .text.LCD_LINE_position:

0000073c <LCD_LINE_position>:
	ERROR_STATE state_error = SUCCESS;
	UINT8_t address =0;
	if(x == 0){
		address = 0x00;
	}
	if(x == 1){
 73c:	81 30       	cpi	r24, 0x01	; 1
 73e:	11 f0       	breq	.+4      	; 0x744 <LCD_LINE_position+0x8>
 740:	90 e0       	ldi	r25, 0x00	; 0
 742:	01 c0       	rjmp	.+2      	; 0x746 <LCD_LINE_position+0xa>
		address = 0x40;
 744:	90 e4       	ldi	r25, 0x40	; 64
	}
	if(x == 2){
 746:	82 30       	cpi	r24, 0x02	; 2
 748:	09 f4       	brne	.+2      	; 0x74c <LCD_LINE_position+0x10>
		address = 0x14;
 74a:	94 e1       	ldi	r25, 0x14	; 20
	}
	if(x == 3){
 74c:	83 30       	cpi	r24, 0x03	; 3
 74e:	09 f4       	brne	.+2      	; 0x752 <LCD_LINE_position+0x16>
		address = 0x54;
 750:	94 e5       	ldi	r25, 0x54	; 84
	}
	if(y < 20){
 752:	64 31       	cpi	r22, 0x14	; 20
 754:	08 f4       	brcc	.+2      	; 0x758 <LCD_LINE_position+0x1c>
		address += y;
 756:	96 0f       	add	r25, r22
	}
	LCD_Write_Command(0x80+address);
 758:	80 e8       	ldi	r24, 0x80	; 128
 75a:	89 0f       	add	r24, r25
 75c:	0e 94 68 01 	call	0x2d0	; 0x2d0 <LCD_Write_Command>
	return state_error;
 760:	81 e0       	ldi	r24, 0x01	; 1
 762:	08 95       	ret

Disassembly of section .text.VR1_init:

000007da <VR1_init>:
 * input: void
 * return: Error State
 */
ERROR_STATE VR1_init(){
	ERROR_STATE state_error = SUCCESS;
	if(ADC_Initializ()){
 7da:	0e 94 b2 03 	call	0x764	; 0x764 <ADC_Initializ>
 7de:	88 23       	and	r24, r24
 7e0:	11 f0       	breq	.+4      	; 0x7e6 <VR1_init+0xc>
		state_error = SUCCESS;
 7e2:	81 e0       	ldi	r24, 0x01	; 1
 7e4:	08 95       	ret
	}else{
		state_error = FAIL;
 7e6:	80 e0       	ldi	r24, 0x00	; 0
	}
	return state_error;
}
 7e8:	08 95       	ret

Disassembly of section .text.VR1_Read:

000007a2 <VR1_Read>:
 * input: void
 * return: Error State
 */
ERROR_STATE VR1_Read(UINT16_t* POT_value){
	ERROR_STATE state_error = SUCCESS;
	if(ADC_Read(ADC_PIN0,POT_value)){
 7a2:	bc 01       	movw	r22, r24
 7a4:	80 e0       	ldi	r24, 0x00	; 0
 7a6:	0e 94 3d 03 	call	0x67a	; 0x67a <ADC_Read>
 7aa:	88 23       	and	r24, r24
 7ac:	11 f0       	breq	.+4      	; 0x7b2 <VR1_Read+0x10>
		state_error = SUCCESS;
 7ae:	81 e0       	ldi	r24, 0x01	; 1
 7b0:	08 95       	ret
	}else{
		state_error = FAIL;
 7b2:	80 e0       	ldi	r24, 0x00	; 0
	}
	return state_error;
}
 7b4:	08 95       	ret

Disassembly of section .text.main:

0000081e <main>:
#include "main.h"


int main() 
{
	app_init();
 81e:	0e 94 e5 03 	call	0x7ca	; 0x7ca <app_init>
	while(1)
	{
		app_main();
 822:	0e 94 19 04 	call	0x832	; 0x832 <app_main>
 826:	fd cf       	rjmp	.-6      	; 0x822 <main+0x4>

Disassembly of section .text.ADC_Initializ:

00000764 <ADC_Initializ>:
 * Description: Function to initialize the Adc
 * input: nothing
 * return: Error State
 */
ERROR_STATE ADC_Initializ(){
	CLR_BIT(ADC_REF_voltage,REF_BIT1);SET_BIT(ADC_REF_voltage,REF_BIT0);
 764:	87 b1       	in	r24, 0x07	; 7
 766:	8f 77       	andi	r24, 0x7F	; 127
 768:	87 b9       	out	0x07, r24	; 7
 76a:	87 b1       	in	r24, 0x07	; 7
 76c:	80 64       	ori	r24, 0x40	; 64
 76e:	87 b9       	out	0x07, r24	; 7
	SET_BIT(ADC_CNTR_State,ADC_EN_BIT);
 770:	86 b1       	in	r24, 0x06	; 6
 772:	80 68       	ori	r24, 0x80	; 128
 774:	86 b9       	out	0x06, r24	; 6
	SET_BIT(ADC_CNTR_State,ADC_PRESCALER_BIT2);SET_BIT(ADC_CNTR_State,ADC_PRESCALER_BIT1);SET_BIT(ADC_CNTR_State,ADC_PRESCALER_BIT0);
 776:	86 b1       	in	r24, 0x06	; 6
 778:	84 60       	ori	r24, 0x04	; 4
 77a:	86 b9       	out	0x06, r24	; 6
 77c:	86 b1       	in	r24, 0x06	; 6
 77e:	82 60       	ori	r24, 0x02	; 2
 780:	86 b9       	out	0x06, r24	; 6
 782:	86 b1       	in	r24, 0x06	; 6
 784:	81 60       	ori	r24, 0x01	; 1
 786:	86 b9       	out	0x06, r24	; 6
	return SUCCESS;
}
 788:	81 e0       	ldi	r24, 0x01	; 1
 78a:	08 95       	ret

Disassembly of section .text.ADC_Read:

0000067a <ADC_Read>:
 * input: channel & pointer to store the Adc value
 * return: Error State
 */
ERROR_STATE ADC_Read(ADC_PIN channel,UINT16_t* adc_value){
	UINT16_t adc_map=0;
	ADC_REF_voltage &= 0xf0;
 67a:	97 b1       	in	r25, 0x07	; 7
 67c:	90 7f       	andi	r25, 0xF0	; 240
 67e:	97 b9       	out	0x07, r25	; 7
	ADC_REF_voltage |= channel;
 680:	97 b1       	in	r25, 0x07	; 7
 682:	89 2b       	or	r24, r25
 684:	87 b9       	out	0x07, r24	; 7
	CLR_BIT(ADC_CNTR_State,ADC_INTERRUPT_EN);
 686:	86 b1       	in	r24, 0x06	; 6
 688:	87 7f       	andi	r24, 0xF7	; 247
 68a:	86 b9       	out	0x06, r24	; 6
	CLR_BIT(ADC_CNTR_State,ADC_AUTO_TRIGGER_EN);
 68c:	86 b1       	in	r24, 0x06	; 6
 68e:	8f 7d       	andi	r24, 0xDF	; 223
 690:	86 b9       	out	0x06, r24	; 6
	SET_BIT(ADC_CNTR_State,ADC_START_CONVERSION);
 692:	86 b1       	in	r24, 0x06	; 6
 694:	80 64       	ori	r24, 0x40	; 64
 696:	86 b9       	out	0x06, r24	; 6
	while(GET_BIT(ADC_CNTR_State,ADC_NORMAL_FLAG));
 698:	36 99       	sbic	0x06, 6	; 6
 69a:	fe cf       	rjmp	.-4      	; 0x698 <ADC_Read+0x1e>
	adc_map |= (UINT16_t)ADCL;
 69c:	24 b1       	in	r18, 0x04	; 4
	adc_map |= (UINT16_t)ADCH << 8;
 69e:	85 b1       	in	r24, 0x05	; 5
 6a0:	90 e0       	ldi	r25, 0x00	; 0
 6a2:	98 2f       	mov	r25, r24
 6a4:	88 27       	eor	r24, r24
 6a6:	82 2b       	or	r24, r18
	*adc_value=adc_map;
 6a8:	fb 01       	movw	r30, r22
 6aa:	91 83       	std	Z+1, r25	; 0x01
 6ac:	80 83       	st	Z, r24
	return SUCCESS;
}
 6ae:	81 e0       	ldi	r24, 0x01	; 1
 6b0:	08 95       	ret

Disassembly of section .text.DIO_SetPin_Direction:

000000d4 <DIO_SetPin_Direction>:
 * return: Error State
 */
ERROR_STATE DIO_SetPin_Direction(DIO_Port port, DIO_Pin pin, DIO_State state)
{
	ERROR_STATE state_error = SUCCESS;
	switch (state)
  d4:	44 23       	and	r20, r20
  d6:	19 f0       	breq	.+6      	; 0xde <DIO_SetPin_Direction+0xa>
  d8:	41 30       	cpi	r20, 0x01	; 1
  da:	e9 f1       	breq	.+122    	; 0x156 <DIO_SetPin_Direction+0x82>
  dc:	74 c0       	rjmp	.+232    	; 0x1c6 <DIO_SetPin_Direction+0xf2>
	{
		case DIO_INPUT:
		switch(port)
  de:	81 30       	cpi	r24, 0x01	; 1
  e0:	99 f0       	breq	.+38     	; 0x108 <DIO_SetPin_Direction+0x34>
  e2:	28 f0       	brcs	.+10     	; 0xee <DIO_SetPin_Direction+0x1a>
  e4:	82 30       	cpi	r24, 0x02	; 2
  e6:	e9 f0       	breq	.+58     	; 0x122 <DIO_SetPin_Direction+0x4e>
  e8:	83 30       	cpi	r24, 0x03	; 3
  ea:	41 f1       	breq	.+80     	; 0x13c <DIO_SetPin_Direction+0x68>
  ec:	6e c0       	rjmp	.+220    	; 0x1ca <DIO_SetPin_Direction+0xf6>
		{
			case DIO_PORTA:
			CLR_BIT(DDRA, pin);
  ee:	2a b3       	in	r18, 0x1a	; 26
  f0:	81 e0       	ldi	r24, 0x01	; 1
  f2:	90 e0       	ldi	r25, 0x00	; 0
  f4:	02 c0       	rjmp	.+4      	; 0xfa <DIO_SetPin_Direction+0x26>
  f6:	88 0f       	add	r24, r24
  f8:	99 1f       	adc	r25, r25
  fa:	6a 95       	dec	r22
  fc:	e2 f7       	brpl	.-8      	; 0xf6 <DIO_SetPin_Direction+0x22>
  fe:	80 95       	com	r24
 100:	82 23       	and	r24, r18
 102:	8a bb       	out	0x1a, r24	; 26
 * input: port & pin & direction
 * return: Error State
 */
ERROR_STATE DIO_SetPin_Direction(DIO_Port port, DIO_Pin pin, DIO_State state)
{
	ERROR_STATE state_error = SUCCESS;
 104:	81 e0       	ldi	r24, 0x01	; 1
		case DIO_INPUT:
		switch(port)
		{
			case DIO_PORTA:
			CLR_BIT(DDRA, pin);
			break;
 106:	08 95       	ret
			case DIO_PORTB:
			CLR_BIT(DDRB, pin);
 108:	27 b3       	in	r18, 0x17	; 23
 10a:	81 e0       	ldi	r24, 0x01	; 1
 10c:	90 e0       	ldi	r25, 0x00	; 0
 10e:	02 c0       	rjmp	.+4      	; 0x114 <DIO_SetPin_Direction+0x40>
 110:	88 0f       	add	r24, r24
 112:	99 1f       	adc	r25, r25
 114:	6a 95       	dec	r22
 116:	e2 f7       	brpl	.-8      	; 0x110 <DIO_SetPin_Direction+0x3c>
 118:	80 95       	com	r24
 11a:	82 23       	and	r24, r18
 11c:	87 bb       	out	0x17, r24	; 23
 * input: port & pin & direction
 * return: Error State
 */
ERROR_STATE DIO_SetPin_Direction(DIO_Port port, DIO_Pin pin, DIO_State state)
{
	ERROR_STATE state_error = SUCCESS;
 11e:	81 e0       	ldi	r24, 0x01	; 1
			case DIO_PORTA:
			CLR_BIT(DDRA, pin);
			break;
			case DIO_PORTB:
			CLR_BIT(DDRB, pin);
			break;
 120:	08 95       	ret
			case DIO_PORTC:
			CLR_BIT(DDRC, pin);
 122:	24 b3       	in	r18, 0x14	; 20
 124:	81 e0       	ldi	r24, 0x01	; 1
 126:	90 e0       	ldi	r25, 0x00	; 0
 128:	02 c0       	rjmp	.+4      	; 0x12e <DIO_SetPin_Direction+0x5a>
 12a:	88 0f       	add	r24, r24
 12c:	99 1f       	adc	r25, r25
 12e:	6a 95       	dec	r22
 130:	e2 f7       	brpl	.-8      	; 0x12a <DIO_SetPin_Direction+0x56>
 132:	80 95       	com	r24
 134:	82 23       	and	r24, r18
 136:	84 bb       	out	0x14, r24	; 20
 * input: port & pin & direction
 * return: Error State
 */
ERROR_STATE DIO_SetPin_Direction(DIO_Port port, DIO_Pin pin, DIO_State state)
{
	ERROR_STATE state_error = SUCCESS;
 138:	81 e0       	ldi	r24, 0x01	; 1
			case DIO_PORTB:
			CLR_BIT(DDRB, pin);
			break;
			case DIO_PORTC:
			CLR_BIT(DDRC, pin);
			break;
 13a:	08 95       	ret
			case DIO_PORTD:
			CLR_BIT(DDRD, pin);
 13c:	21 b3       	in	r18, 0x11	; 17
 13e:	81 e0       	ldi	r24, 0x01	; 1
 140:	90 e0       	ldi	r25, 0x00	; 0
 142:	02 c0       	rjmp	.+4      	; 0x148 <DIO_SetPin_Direction+0x74>
 144:	88 0f       	add	r24, r24
 146:	99 1f       	adc	r25, r25
 148:	6a 95       	dec	r22
 14a:	e2 f7       	brpl	.-8      	; 0x144 <DIO_SetPin_Direction+0x70>
 14c:	80 95       	com	r24
 14e:	82 23       	and	r24, r18
 150:	81 bb       	out	0x11, r24	; 17
 * input: port & pin & direction
 * return: Error State
 */
ERROR_STATE DIO_SetPin_Direction(DIO_Port port, DIO_Pin pin, DIO_State state)
{
	ERROR_STATE state_error = SUCCESS;
 152:	81 e0       	ldi	r24, 0x01	; 1
			case DIO_PORTC:
			CLR_BIT(DDRC, pin);
			break;
			case DIO_PORTD:
			CLR_BIT(DDRD, pin);
			break;
 154:	08 95       	ret
			state_error = FAIL;
			break;
		}
		break;
		case DIO_OUTPUT:
		switch(port)
 156:	81 30       	cpi	r24, 0x01	; 1
 158:	91 f0       	breq	.+36     	; 0x17e <DIO_SetPin_Direction+0xaa>
 15a:	28 f0       	brcs	.+10     	; 0x166 <DIO_SetPin_Direction+0x92>
 15c:	82 30       	cpi	r24, 0x02	; 2
 15e:	d9 f0       	breq	.+54     	; 0x196 <DIO_SetPin_Direction+0xc2>
 160:	83 30       	cpi	r24, 0x03	; 3
 162:	29 f1       	breq	.+74     	; 0x1ae <DIO_SetPin_Direction+0xda>
 164:	34 c0       	rjmp	.+104    	; 0x1ce <DIO_SetPin_Direction+0xfa>
		{
			case DIO_PORTA:
			SET_BIT(DDRA, pin);
 166:	2a b3       	in	r18, 0x1a	; 26
 168:	81 e0       	ldi	r24, 0x01	; 1
 16a:	90 e0       	ldi	r25, 0x00	; 0
 16c:	02 c0       	rjmp	.+4      	; 0x172 <DIO_SetPin_Direction+0x9e>
 16e:	88 0f       	add	r24, r24
 170:	99 1f       	adc	r25, r25
 172:	6a 95       	dec	r22
 174:	e2 f7       	brpl	.-8      	; 0x16e <DIO_SetPin_Direction+0x9a>
 176:	82 2b       	or	r24, r18
 178:	8a bb       	out	0x1a, r24	; 26
 * input: port & pin & direction
 * return: Error State
 */
ERROR_STATE DIO_SetPin_Direction(DIO_Port port, DIO_Pin pin, DIO_State state)
{
	ERROR_STATE state_error = SUCCESS;
 17a:	81 e0       	ldi	r24, 0x01	; 1
		case DIO_OUTPUT:
		switch(port)
		{
			case DIO_PORTA:
			SET_BIT(DDRA, pin);
			break;
 17c:	08 95       	ret
			case DIO_PORTB:
			SET_BIT(DDRB, pin);
 17e:	27 b3       	in	r18, 0x17	; 23
 180:	81 e0       	ldi	r24, 0x01	; 1
 182:	90 e0       	ldi	r25, 0x00	; 0
 184:	02 c0       	rjmp	.+4      	; 0x18a <DIO_SetPin_Direction+0xb6>
 186:	88 0f       	add	r24, r24
 188:	99 1f       	adc	r25, r25
 18a:	6a 95       	dec	r22
 18c:	e2 f7       	brpl	.-8      	; 0x186 <DIO_SetPin_Direction+0xb2>
 18e:	82 2b       	or	r24, r18
 190:	87 bb       	out	0x17, r24	; 23
 * input: port & pin & direction
 * return: Error State
 */
ERROR_STATE DIO_SetPin_Direction(DIO_Port port, DIO_Pin pin, DIO_State state)
{
	ERROR_STATE state_error = SUCCESS;
 192:	81 e0       	ldi	r24, 0x01	; 1
			case DIO_PORTA:
			SET_BIT(DDRA, pin);
			break;
			case DIO_PORTB:
			SET_BIT(DDRB, pin);
			break;
 194:	08 95       	ret
			case DIO_PORTC:
			SET_BIT(DDRC, pin);
 196:	24 b3       	in	r18, 0x14	; 20
 198:	81 e0       	ldi	r24, 0x01	; 1
 19a:	90 e0       	ldi	r25, 0x00	; 0
 19c:	02 c0       	rjmp	.+4      	; 0x1a2 <DIO_SetPin_Direction+0xce>
 19e:	88 0f       	add	r24, r24
 1a0:	99 1f       	adc	r25, r25
 1a2:	6a 95       	dec	r22
 1a4:	e2 f7       	brpl	.-8      	; 0x19e <DIO_SetPin_Direction+0xca>
 1a6:	82 2b       	or	r24, r18
 1a8:	84 bb       	out	0x14, r24	; 20
 * input: port & pin & direction
 * return: Error State
 */
ERROR_STATE DIO_SetPin_Direction(DIO_Port port, DIO_Pin pin, DIO_State state)
{
	ERROR_STATE state_error = SUCCESS;
 1aa:	81 e0       	ldi	r24, 0x01	; 1
			case DIO_PORTB:
			SET_BIT(DDRB, pin);
			break;
			case DIO_PORTC:
			SET_BIT(DDRC, pin);
			break;
 1ac:	08 95       	ret
			case DIO_PORTD:
			SET_BIT(DDRD, pin);
 1ae:	21 b3       	in	r18, 0x11	; 17
 1b0:	81 e0       	ldi	r24, 0x01	; 1
 1b2:	90 e0       	ldi	r25, 0x00	; 0
 1b4:	02 c0       	rjmp	.+4      	; 0x1ba <DIO_SetPin_Direction+0xe6>
 1b6:	88 0f       	add	r24, r24
 1b8:	99 1f       	adc	r25, r25
 1ba:	6a 95       	dec	r22
 1bc:	e2 f7       	brpl	.-8      	; 0x1b6 <DIO_SetPin_Direction+0xe2>
 1be:	82 2b       	or	r24, r18
 1c0:	81 bb       	out	0x11, r24	; 17
 * input: port & pin & direction
 * return: Error State
 */
ERROR_STATE DIO_SetPin_Direction(DIO_Port port, DIO_Pin pin, DIO_State state)
{
	ERROR_STATE state_error = SUCCESS;
 1c2:	81 e0       	ldi	r24, 0x01	; 1
			case DIO_PORTC:
			SET_BIT(DDRC, pin);
			break;
			case DIO_PORTD:
			SET_BIT(DDRD, pin);
			break;
 1c4:	08 95       	ret
 * input: port & pin & direction
 * return: Error State
 */
ERROR_STATE DIO_SetPin_Direction(DIO_Port port, DIO_Pin pin, DIO_State state)
{
	ERROR_STATE state_error = SUCCESS;
 1c6:	81 e0       	ldi	r24, 0x01	; 1
 1c8:	08 95       	ret
			break;
			case DIO_PORTD:
			CLR_BIT(DDRD, pin);
			break;
			default:
			state_error = FAIL;
 1ca:	80 e0       	ldi	r24, 0x00	; 0
 1cc:	08 95       	ret
			break;
			case DIO_PORTD:
			SET_BIT(DDRD, pin);
			break;
			default:
			state_error = FAIL;
 1ce:	80 e0       	ldi	r24, 0x00	; 0
			break;
		}
		break;
	}
	return state_error;
}
 1d0:	08 95       	ret

Disassembly of section .text.DIO_SetPin_Value:

000001d2 <DIO_SetPin_Value>:
 * return: Error State
 */
ERROR_STATE DIO_SetPin_Value(DIO_Port port, DIO_Pin pin, DIO_Status status)
{
ERROR_STATE state_error = SUCCESS;
	switch (status)
 1d2:	44 23       	and	r20, r20
 1d4:	19 f0       	breq	.+6      	; 0x1dc <DIO_SetPin_Value+0xa>
 1d6:	41 30       	cpi	r20, 0x01	; 1
 1d8:	e9 f1       	breq	.+122    	; 0x254 <DIO_SetPin_Value+0x82>
 1da:	74 c0       	rjmp	.+232    	; 0x2c4 <DIO_SetPin_Value+0xf2>
	{
		case DIO_LOW:
		switch(port)
 1dc:	81 30       	cpi	r24, 0x01	; 1
 1de:	99 f0       	breq	.+38     	; 0x206 <DIO_SetPin_Value+0x34>
 1e0:	28 f0       	brcs	.+10     	; 0x1ec <DIO_SetPin_Value+0x1a>
 1e2:	82 30       	cpi	r24, 0x02	; 2
 1e4:	e9 f0       	breq	.+58     	; 0x220 <DIO_SetPin_Value+0x4e>
 1e6:	83 30       	cpi	r24, 0x03	; 3
 1e8:	41 f1       	breq	.+80     	; 0x23a <DIO_SetPin_Value+0x68>
 1ea:	6e c0       	rjmp	.+220    	; 0x2c8 <DIO_SetPin_Value+0xf6>
		{
			case DIO_PORTA:
			CLR_BIT(PORTA, pin);
 1ec:	2b b3       	in	r18, 0x1b	; 27
 1ee:	81 e0       	ldi	r24, 0x01	; 1
 1f0:	90 e0       	ldi	r25, 0x00	; 0
 1f2:	02 c0       	rjmp	.+4      	; 0x1f8 <DIO_SetPin_Value+0x26>
 1f4:	88 0f       	add	r24, r24
 1f6:	99 1f       	adc	r25, r25
 1f8:	6a 95       	dec	r22
 1fa:	e2 f7       	brpl	.-8      	; 0x1f4 <DIO_SetPin_Value+0x22>
 1fc:	80 95       	com	r24
 1fe:	82 23       	and	r24, r18
 200:	8b bb       	out	0x1b, r24	; 27
 * input: port & pin & value
 * return: Error State
 */
ERROR_STATE DIO_SetPin_Value(DIO_Port port, DIO_Pin pin, DIO_Status status)
{
ERROR_STATE state_error = SUCCESS;
 202:	81 e0       	ldi	r24, 0x01	; 1
		case DIO_LOW:
		switch(port)
		{
			case DIO_PORTA:
			CLR_BIT(PORTA, pin);
			break;
 204:	08 95       	ret
			case DIO_PORTB:
			CLR_BIT(PORTB, pin);
 206:	28 b3       	in	r18, 0x18	; 24
 208:	81 e0       	ldi	r24, 0x01	; 1
 20a:	90 e0       	ldi	r25, 0x00	; 0
 20c:	02 c0       	rjmp	.+4      	; 0x212 <DIO_SetPin_Value+0x40>
 20e:	88 0f       	add	r24, r24
 210:	99 1f       	adc	r25, r25
 212:	6a 95       	dec	r22
 214:	e2 f7       	brpl	.-8      	; 0x20e <DIO_SetPin_Value+0x3c>
 216:	80 95       	com	r24
 218:	82 23       	and	r24, r18
 21a:	88 bb       	out	0x18, r24	; 24
 * input: port & pin & value
 * return: Error State
 */
ERROR_STATE DIO_SetPin_Value(DIO_Port port, DIO_Pin pin, DIO_Status status)
{
ERROR_STATE state_error = SUCCESS;
 21c:	81 e0       	ldi	r24, 0x01	; 1
			case DIO_PORTA:
			CLR_BIT(PORTA, pin);
			break;
			case DIO_PORTB:
			CLR_BIT(PORTB, pin);
			break;
 21e:	08 95       	ret
			case DIO_PORTC:
			CLR_BIT(PORTC, pin);
 220:	25 b3       	in	r18, 0x15	; 21
 222:	81 e0       	ldi	r24, 0x01	; 1
 224:	90 e0       	ldi	r25, 0x00	; 0
 226:	02 c0       	rjmp	.+4      	; 0x22c <DIO_SetPin_Value+0x5a>
 228:	88 0f       	add	r24, r24
 22a:	99 1f       	adc	r25, r25
 22c:	6a 95       	dec	r22
 22e:	e2 f7       	brpl	.-8      	; 0x228 <DIO_SetPin_Value+0x56>
 230:	80 95       	com	r24
 232:	82 23       	and	r24, r18
 234:	85 bb       	out	0x15, r24	; 21
 * input: port & pin & value
 * return: Error State
 */
ERROR_STATE DIO_SetPin_Value(DIO_Port port, DIO_Pin pin, DIO_Status status)
{
ERROR_STATE state_error = SUCCESS;
 236:	81 e0       	ldi	r24, 0x01	; 1
			case DIO_PORTB:
			CLR_BIT(PORTB, pin);
			break;
			case DIO_PORTC:
			CLR_BIT(PORTC, pin);
			break;
 238:	08 95       	ret
			case DIO_PORTD:
			CLR_BIT(PORTD, pin);
 23a:	22 b3       	in	r18, 0x12	; 18
 23c:	81 e0       	ldi	r24, 0x01	; 1
 23e:	90 e0       	ldi	r25, 0x00	; 0
 240:	02 c0       	rjmp	.+4      	; 0x246 <DIO_SetPin_Value+0x74>
 242:	88 0f       	add	r24, r24
 244:	99 1f       	adc	r25, r25
 246:	6a 95       	dec	r22
 248:	e2 f7       	brpl	.-8      	; 0x242 <DIO_SetPin_Value+0x70>
 24a:	80 95       	com	r24
 24c:	82 23       	and	r24, r18
 24e:	82 bb       	out	0x12, r24	; 18
 * input: port & pin & value
 * return: Error State
 */
ERROR_STATE DIO_SetPin_Value(DIO_Port port, DIO_Pin pin, DIO_Status status)
{
ERROR_STATE state_error = SUCCESS;
 250:	81 e0       	ldi	r24, 0x01	; 1
			case DIO_PORTC:
			CLR_BIT(PORTC, pin);
			break;
			case DIO_PORTD:
			CLR_BIT(PORTD, pin);
			break;
 252:	08 95       	ret
			state_error = FAIL;
			break;
		}
		break;
		case DIO_HIGH:
		switch(port)
 254:	81 30       	cpi	r24, 0x01	; 1
 256:	91 f0       	breq	.+36     	; 0x27c <DIO_SetPin_Value+0xaa>
 258:	28 f0       	brcs	.+10     	; 0x264 <DIO_SetPin_Value+0x92>
 25a:	82 30       	cpi	r24, 0x02	; 2
 25c:	d9 f0       	breq	.+54     	; 0x294 <DIO_SetPin_Value+0xc2>
 25e:	83 30       	cpi	r24, 0x03	; 3
 260:	29 f1       	breq	.+74     	; 0x2ac <DIO_SetPin_Value+0xda>
 262:	34 c0       	rjmp	.+104    	; 0x2cc <DIO_SetPin_Value+0xfa>
		{
			case DIO_PORTA:
			SET_BIT(PORTA, pin);
 264:	2b b3       	in	r18, 0x1b	; 27
 266:	81 e0       	ldi	r24, 0x01	; 1
 268:	90 e0       	ldi	r25, 0x00	; 0
 26a:	02 c0       	rjmp	.+4      	; 0x270 <DIO_SetPin_Value+0x9e>
 26c:	88 0f       	add	r24, r24
 26e:	99 1f       	adc	r25, r25
 270:	6a 95       	dec	r22
 272:	e2 f7       	brpl	.-8      	; 0x26c <DIO_SetPin_Value+0x9a>
 274:	82 2b       	or	r24, r18
 276:	8b bb       	out	0x1b, r24	; 27
 * input: port & pin & value
 * return: Error State
 */
ERROR_STATE DIO_SetPin_Value(DIO_Port port, DIO_Pin pin, DIO_Status status)
{
ERROR_STATE state_error = SUCCESS;
 278:	81 e0       	ldi	r24, 0x01	; 1
		case DIO_HIGH:
		switch(port)
		{
			case DIO_PORTA:
			SET_BIT(PORTA, pin);
			break;
 27a:	08 95       	ret
			case DIO_PORTB:
			SET_BIT(PORTB, pin);
 27c:	28 b3       	in	r18, 0x18	; 24
 27e:	81 e0       	ldi	r24, 0x01	; 1
 280:	90 e0       	ldi	r25, 0x00	; 0
 282:	02 c0       	rjmp	.+4      	; 0x288 <DIO_SetPin_Value+0xb6>
 284:	88 0f       	add	r24, r24
 286:	99 1f       	adc	r25, r25
 288:	6a 95       	dec	r22
 28a:	e2 f7       	brpl	.-8      	; 0x284 <DIO_SetPin_Value+0xb2>
 28c:	82 2b       	or	r24, r18
 28e:	88 bb       	out	0x18, r24	; 24
 * input: port & pin & value
 * return: Error State
 */
ERROR_STATE DIO_SetPin_Value(DIO_Port port, DIO_Pin pin, DIO_Status status)
{
ERROR_STATE state_error = SUCCESS;
 290:	81 e0       	ldi	r24, 0x01	; 1
			case DIO_PORTA:
			SET_BIT(PORTA, pin);
			break;
			case DIO_PORTB:
			SET_BIT(PORTB, pin);
			break;
 292:	08 95       	ret
			case DIO_PORTC:
			SET_BIT(PORTC, pin);
 294:	25 b3       	in	r18, 0x15	; 21
 296:	81 e0       	ldi	r24, 0x01	; 1
 298:	90 e0       	ldi	r25, 0x00	; 0
 29a:	02 c0       	rjmp	.+4      	; 0x2a0 <DIO_SetPin_Value+0xce>
 29c:	88 0f       	add	r24, r24
 29e:	99 1f       	adc	r25, r25
 2a0:	6a 95       	dec	r22
 2a2:	e2 f7       	brpl	.-8      	; 0x29c <DIO_SetPin_Value+0xca>
 2a4:	82 2b       	or	r24, r18
 2a6:	85 bb       	out	0x15, r24	; 21
 * input: port & pin & value
 * return: Error State
 */
ERROR_STATE DIO_SetPin_Value(DIO_Port port, DIO_Pin pin, DIO_Status status)
{
ERROR_STATE state_error = SUCCESS;
 2a8:	81 e0       	ldi	r24, 0x01	; 1
			case DIO_PORTB:
			SET_BIT(PORTB, pin);
			break;
			case DIO_PORTC:
			SET_BIT(PORTC, pin);
			break;
 2aa:	08 95       	ret
			case DIO_PORTD:
			SET_BIT(PORTD, pin);
 2ac:	22 b3       	in	r18, 0x12	; 18
 2ae:	81 e0       	ldi	r24, 0x01	; 1
 2b0:	90 e0       	ldi	r25, 0x00	; 0
 2b2:	02 c0       	rjmp	.+4      	; 0x2b8 <DIO_SetPin_Value+0xe6>
 2b4:	88 0f       	add	r24, r24
 2b6:	99 1f       	adc	r25, r25
 2b8:	6a 95       	dec	r22
 2ba:	e2 f7       	brpl	.-8      	; 0x2b4 <DIO_SetPin_Value+0xe2>
 2bc:	82 2b       	or	r24, r18
 2be:	82 bb       	out	0x12, r24	; 18
 * input: port & pin & value
 * return: Error State
 */
ERROR_STATE DIO_SetPin_Value(DIO_Port port, DIO_Pin pin, DIO_Status status)
{
ERROR_STATE state_error = SUCCESS;
 2c0:	81 e0       	ldi	r24, 0x01	; 1
			case DIO_PORTC:
			SET_BIT(PORTC, pin);
			break;
			case DIO_PORTD:
			SET_BIT(PORTD, pin);
			break;
 2c2:	08 95       	ret
 * input: port & pin & value
 * return: Error State
 */
ERROR_STATE DIO_SetPin_Value(DIO_Port port, DIO_Pin pin, DIO_Status status)
{
ERROR_STATE state_error = SUCCESS;
 2c4:	81 e0       	ldi	r24, 0x01	; 1
 2c6:	08 95       	ret
			break;
			case DIO_PORTD:
			CLR_BIT(PORTD, pin);
			break;
			default:
			state_error = FAIL;
 2c8:	80 e0       	ldi	r24, 0x00	; 0
 2ca:	08 95       	ret
			break;
			case DIO_PORTD:
			SET_BIT(PORTD, pin);
			break;
			default:
			state_error = FAIL;
 2cc:	80 e0       	ldi	r24, 0x00	; 0
			break;
		}
		break;
	}
	return state_error;
}
 2ce:	08 95       	ret

Disassembly of section .text.Set_Global_INT:

00000710 <Set_Global_INT>:
 * input: mode
 * return: Error State
 */
ERROR_STATE Set_Global_INT(GLB_MODE mode){
	ERROR_STATE state_error = SUCCESS;
	SREG |= mode;
 710:	9f b7       	in	r25, 0x3f	; 63
 712:	98 2b       	or	r25, r24
 714:	9f bf       	out	0x3f, r25	; 63
	if(mode == ON){
 716:	80 38       	cpi	r24, 0x80	; 128
 718:	29 f4       	brne	.+10     	; 0x724 <Set_Global_INT+0x14>
		if(!GET_BIT(SREG,7)){
 71a:	0f b6       	in	r0, 0x3f	; 63
 71c:	07 fc       	sbrc	r0, 7
 71e:	08 c0       	rjmp	.+16     	; 0x730 <Set_Global_INT+0x20>
			state_error = FAIL;
 720:	80 e0       	ldi	r24, 0x00	; 0
 722:	08 95       	ret
		}else{
			state_error = SUCCESS;
		}
	}else{
		if(mode == OFF){
 724:	81 11       	cpse	r24, r1
 726:	06 c0       	rjmp	.+12     	; 0x734 <Set_Global_INT+0x24>
			if(GET_BIT(SREG,7)){
 728:	0f b6       	in	r0, 0x3f	; 63
 72a:	07 fe       	sbrs	r0, 7
 72c:	05 c0       	rjmp	.+10     	; 0x738 <Set_Global_INT+0x28>
 72e:	08 95       	ret
	SREG |= mode;
	if(mode == ON){
		if(!GET_BIT(SREG,7)){
			state_error = FAIL;
		}else{
			state_error = SUCCESS;
 730:	81 e0       	ldi	r24, 0x01	; 1
 732:	08 95       	ret
				state_error = FAIL;
			}else{
				state_error = SUCCESS;
			}
		}else{
			state_error = FAIL;
 734:	80 e0       	ldi	r24, 0x00	; 0
 736:	08 95       	ret
	}else{
		if(mode == OFF){
			if(GET_BIT(SREG,7)){
				state_error = FAIL;
			}else{
				state_error = SUCCESS;
 738:	81 e0       	ldi	r24, 0x01	; 1
		}else{
			state_error = FAIL;
		}
	}
	return state_error;
}
 73a:	08 95       	ret

Disassembly of section .text.timer0_init:

000007b6 <timer0_init>:
 7b6:	85 e8       	ldi	r24, 0x85	; 133
 7b8:	83 bf       	out	0x33, r24	; 51
 7ba:	81 e0       	ldi	r24, 0x01	; 1
 7bc:	89 bf       	out	0x39, r24	; 57
 7be:	8c e4       	ldi	r24, 0x4C	; 76
 7c0:	82 bf       	out	0x32, r24	; 50
 7c2:	80 e8       	ldi	r24, 0x80	; 128
 7c4:	0e 94 88 03 	call	0x710	; 0x710 <Set_Global_INT>
 7c8:	08 95       	ret

Disassembly of section .text.timer0_deinit:

00000828 <timer0_deinit>:
 828:	13 be       	out	0x33, r1	; 51
 82a:	80 e0       	ldi	r24, 0x00	; 0
 82c:	0e 94 88 03 	call	0x710	; 0x710 <Set_Global_INT>
 830:	08 95       	ret

Disassembly of section .text.__dummy_fini:

00000842 <_fini>:
 842:	08 95       	ret

Disassembly of section .text.__dummy_funcs_on_exit:

00000844 <__funcs_on_exit>:
 844:	08 95       	ret

Disassembly of section .text.__dummy_simulator_exit:

00000846 <__simulator_exit>:
 846:	08 95       	ret

Disassembly of section .text.exit:

0000078c <exit>:
 78c:	ec 01       	movw	r28, r24
 78e:	0e 94 22 04 	call	0x844	; 0x844 <__funcs_on_exit>
 792:	0e 94 21 04 	call	0x842	; 0x842 <_fini>
 796:	ce 01       	movw	r24, r28
 798:	0e 94 23 04 	call	0x846	; 0x846 <__simulator_exit>
 79c:	ce 01       	movw	r24, r28
 79e:	0e 94 1f 04 	call	0x83e	; 0x83e <_Exit>

Disassembly of section .text._Exit:

0000083e <_Exit>:
 83e:	0e 94 55 00 	call	0xaa	; 0xaa <_exit>
